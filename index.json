[{"content":"","date":"16 August 2022","permalink":"/tags/bash/","section":"Tags","summary":"","title":"bash"},{"content":" Telling your future self exactly where to find that tool you need is always a good idea. Photo by Lachlan Donald on Unsplash I often find myself writing small bash scripts for doing repetitive tasks on various *nix machines where I may not 100% know which applications are installed. I\u0026rsquo;ve come up with a bash function to solve this problem that I thought was worth sharing on a quick post.\nThis works especially well for internally developed applications where the latest version needs to be hunted down every time and allows me to get whatever application I need installed quickly from a known trusted location.\nThe function has also proved useful for adding to shared scripts within my team. It helps notify people that the script will not work before hitting errors for missing installed tools and it allows me to show where I\u0026rsquo;ve sourced the required applications that they need in order to use the script.\ncheck_installed() { required_applications=( \u0026#34;terraform\u0026#34; \u0026#34;vault\u0026#34; \u0026#34;jq\u0026#34; \u0026#34;franks_tool\u0026#34; ) app_link_terraform=\u0026#34;https://terraform.io/downloads\u0026#34; app_link_vault=\u0026#34;https://vaultproject.io/downloads\u0026#34; app_link_jq=\u0026#34;https://stedolan.github.io/jq/download\u0026#34; app_link_franks_tool=\u0026#34;Ask Frank for the latest binary\u0026#34; missing_applications=() for app in \u0026#34;${required_applications[@]}\u0026#34;; do if ! command -v \u0026#34;$app\u0026#34; \u0026amp;\u0026gt; /dev/null; then missing_applications+=(\u0026#34;$app\u0026#34;) fi done if [ ${#missing_applications[@]} -gt 0 ]; then echo -e \u0026#34;Required applications to use this script are not currently installed.\\n\u0026#34; echo \u0026#34;Please install the following before running the script again:\u0026#34; for app in \u0026#34;${missing_applications[@]}\u0026#34;; do link=\u0026#34;app_link_$app\u0026#34; echo \u0026#34; - $app, ${!link}\u0026#34; done exit else echo \u0026#34;Required applications are installed.\u0026#34; fi } Usage # To use this function, just copy it into any bash script and add check_installed to the main flow. Edit the the expandable list of required applications (required_applications) and where to find them (app_link_appname).\nBe sure to match the exact appname in the app_link_x variable since this is used to assign the application to a specific message for getting the app installed.\nHow it works # After some Googling/Stack Overflow searching on the best way to determine whether a CLI application is installed, I settled on using the Bash Builtin command since this will return whether an application is found on the PATH and establish if the application would be available for bash to run.\nUsing the -v option will only return a description of command rather than executing the application itself, which could be unhelpful if executing the application is not yet intended. Using this option for a present application will return a status of zero if the command is found and non-zero if it is not. This allows for using this bash builtin in a simple if statement to determine whether an application is available to bash.\nAs noted on the Stack Overflow answer, this is also POSIX compatible way of doing it and should be standard across different *nix environments with different Unix shells (e.g. sh, bash, zsh, fish).\n","date":"16 August 2022","permalink":"/blog/bash-function-for-checking-installed-applications/","section":"Blogs","summary":"Telling your future self exactly where to find that tool you need is always a good idea.","title":"Bash Function for Checking Installed Applications"},{"content":"","date":"16 August 2022","permalink":"/blog/","section":"Blogs","summary":"","title":"Blogs"},{"content":"","date":"16 August 2022","permalink":"/","section":"h0wl","summary":"","title":"h0wl"},{"content":"","date":"16 August 2022","permalink":"/tags/programming/","section":"Tags","summary":"","title":"programming"},{"content":"","date":"16 August 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"21 March 2022","permalink":"/tags/golang/","section":"Tags","summary":"","title":"golang"},{"content":" Photo by Chinmay Bhattar on Unsplash I have recently been spending some time learning Go and I wrote my first command-line interface (CLI) tool at work.\nWhen I make CLI tools or scripts, I like trying to make the output as clear and easy as possible to understand quickly by highlighting important information for people using them. This is usually achieved through using color or different font choices (bold, italic, etc.). While I absolutely am not a Golang expert, I found what I think is a nice flexible way of colorizing CLI output for macOS/Linux terminals. This will also work for CLI applications run via the Windows Terminal, which implemented support for ANSI escape sequences in 2019.\nI noticed that there are a number of libraries written by people on GitHub that offer \u0026ldquo;easy\u0026rdquo; ways to do what I\u0026rsquo;m doing here, but I would rather implement a simple function in my script that does this for me than need a whole new dependency added to all my scripts.\nColor Function and Expected Variables # var ( // Colors and font options via ANSI escape codes Reset = \u0026#34;\\033[0m\u0026#34; Black = \u0026#34;\\033[30m\u0026#34; Red = \u0026#34;\\033[31m\u0026#34; Green = \u0026#34;\\033[32m\u0026#34; Yellow = \u0026#34;\\033[33m\u0026#34; Blue = \u0026#34;\\033[34m\u0026#34; Magenta = \u0026#34;\\033[35m\u0026#34; Cyan = \u0026#34;\\033[36m\u0026#34; Gray = \u0026#34;\\033[37m\u0026#34; White = \u0026#34;\\033[97m\u0026#34; Bold = \u0026#34;\\033[1m\u0026#34; Italic = \u0026#34;\\033[3m\u0026#34; Underline = \u0026#34;\\033[4m\u0026#34; Invert = \u0026#34;\\033[7m\u0026#34; ) func Color(input interface{}, color ...string) string { var s string c := \u0026#34;\u0026#34; for i := range color { c = c + color[i] } switch v := input.(type) { case int: s = c + strconv.Itoa(v) + Reset case bool: s = c + strconv.FormatBool(v) + Reset case []string: s = c + strings.Join(v, \u0026#34;, \u0026#34;) + Reset case string: s = c + v + Reset default: fmt.Printf(\u0026#34;Unsupported type provided to Color func - %T\\n\u0026#34;, v) } return s } The example script below shows how the declared color variables can be implemented using a function that takes different input types (int, bool, string, and slice of strings) and outputs the required string with the ANSI escape sequences attached.\nIf a different type is required for printing out in color to the console, it can be added as a new switch case in the Color function and doing the necessary conversion to make the input type into a string. The way I have the function configured now, the default case will print out a message saying that the type provided to the Color function is not supported if one is provided that does not have a switch case.\nExample Go Script # The way the function works allows multiple font choices and color option to be applied to a single input.\nFor example, the line with fmt.Println(Color(fruits, **Blue, Bold, Underline, Italic, Invert**)) takes the fruits slice and applies a list of colorizing options against it. Only a single color can be applied using the function though, so if you want multiple colors on a single line, you\u0026rsquo;ll need to split it out like the following:\nfmt.Printf(Color(\u0026quot;My fruit list has %s %s\\n\u0026quot;, **Green**), Color(len(fruits), **Magenta, Bold**), Color(\u0026quot;items.\u0026quot;, **Green**))\nOutput of the example script in the Windows Terminal ","date":"21 March 2022","permalink":"/blog/simple-cli-colorizing-in-go/","section":"Blogs","summary":"Photo by Chinmay Bhattar on Unsplash I have recently been spending some time learning Go and I wrote my first command-line interface (CLI) tool at work.","title":"Simple CLI Colorizing in Go"},{"content":"","date":"30 August 2021","permalink":"/tags/aws/","section":"Tags","summary":"","title":"aws"},{"content":"","date":"30 August 2021","permalink":"/tags/cloud/","section":"Tags","summary":"","title":"cloud"},{"content":"","date":"30 August 2021","permalink":"/tags/python/","section":"Tags","summary":"","title":"python"},{"content":"","date":"30 August 2021","permalink":"/tags/security/","section":"Tags","summary":"","title":"security"},{"content":" Have you ever wanted to manually setup Slack bot token rotation with server-less infrastructure in AWS? Photo by Stephen Phillips - Hostreviews.co.uk on Unsplash When you setup a new Slack bot, you have the option to configure it with expiring tokens used for communicating with Slack. This can be desirable if you do not want your Bot tokens to sit around aging and potentially leaking/getting compromised in some way. Slack recommends configuring this for \u0026ldquo;developers building on or for security-minded organizations\u0026rdquo;.\nThis generally provides an extra layer of security for your access tokens that can be used to do anything your Bot can do in any Slack instance it is installed.\nRecently with the \u0026ldquo;server-less\u0026rdquo; Slack bot deployment I\u0026rsquo;ve been working on, I found it difficult to find documentation online for standing up infrastructure in AWS that would refresh my bot token reliably before it expired. Slack\u0026rsquo;s expiring tokens have a lifetime of 12 hours in which they need to be refreshed, but I found that freshing them slightly more often increased reliability of storing them in Secrets Manager.\nI discovered my solution to this issue using a 2018 article from AWS on rotating Twitter API keys as my template. In this article, the author suggests using AWS Secrets Manager with a customized Lambda function that runs all the token refresh calls against Twitter\u0026rsquo;s API to facilitate the rotation and to replace the stored secret in AWS. I made mine do the same against Slack\u0026rsquo;s API.\nHowever, Secrets Manager has a limitation in that you can only choose 1 day as the minimum rotation period for a secret (and this 1 day rotation period can be as long as 48 hours if you\u0026rsquo;re unlucky with the randomization). I don\u0026rsquo;t think AWS expected this tool to be used for things like API keys that require shorter-lived credentials. To get around this limitation, I thought to use a scheduled CloudWatch event rule to trigger this rotation Lambda function within the 12 hour lifespan of the token. Conveniently, these CloudWatch event rules can be scheduled like a cron job on a Unix system.\nIn my deployment, I tried a few different intervals for freshing the token. Initially, I tested it for a couple weeks refreshing it every 10 minutes to simulate months of refresh cycles and it never got out of sync. In order to reduce the amount of time my Lambda functions were running, I extended my CloudWatch rule to run every 10 hours. With this single token refresh in the token lifetime, I did run into syncing issues where the token would expire if the refresh didn\u0026rsquo;t go exactly right.\nI ended up with a happy medium where the refresh happens every 4 hours (3 opportunities in the token\u0026rsquo;s lifetime) and I have not had any syncing issues and use of expiring token has been stable.\nAlthough the Bolt library can help do this refresh process auto-magically, I\u0026rsquo;ve found it beneficial to have full control over my tokens and to understand the mechanisms behind the secret update process in Secrets Manager. I\u0026rsquo;ve also been trying to make my Lambda functions as lightweight and fast as possible, so I decided to stick with the Python slack_sdk library rather than Bolt in the hopes that my functions will be faster and lighter.\nThis guide was written and created with Python version 3.8. If you are using a different version for your bot, you will need to change all version references to the version you are using.\nAWS Console Guide # Secrets Manager # First you will need to create the Slack bot secret in AWS Secrets Manager.\nGo to AWS Secrets Manager in your console and click \u0026ldquo;Store a new secret\u0026rdquo;. Select \u0026ldquo;Other type of secrets\u0026rdquo; for the secret type and input your Slack secrets as shown below (you won\u0026rsquo;t yet have a Slack refresh token if you haven\u0026rsquo;t exchanged your non-expiring token for an expiring one). Input the name of the secret e.g. \u0026ldquo;slack-bot-secrets\u0026rdquo;. Automatic secret rotation will be disabled for now. Scroll down and click \u0026ldquo;Store\u0026rdquo; on the last page after confirming all your configurations. Click the created secret and note down the secret ARN. You will need it in later steps. Lambda Function Layer # Second, you will need the slack_sdk layer setup for the Lambda function. For my own deployment, I am using the slack_sdk library in multiple Lambda functions and the layer allows the dependency to easily be shared across multiple functions and allows for easier maintenance/troubleshooting.\nCreate the required slack_sdk zip file for uploading to the Lambda Layer. Run the following commands (for Linux/Mac, they won\u0026rsquo;t be very different on Windows with a similar zip utility): $ pip install --target ./python/lib/python3.8/site-packages slack_sdk $ zip -r slack_sdk.zip python Within the AWS Lambda service in your AWS console, go to Layers on the left hand side and click \u0026ldquo;Create Layer\u0026rdquo;. Enter the name \u0026ldquo;slack_sdk\u0026rdquo; for the layer, upload the zip created in step 1, select Python 3.8 for the compatible runtime, and click \u0026ldquo;Create\u0026rdquo;. This Layer will now be available for any Lambda function that needs it. Main Lambda Function # Third, you need to create the Lambda functions that will be doing the Slack bot token rotation.\nYou need to setup your first Lambda function for doing the rotation - slack-bot-rotation.py below has the code that will be used by Secrets Manager to rotate the token. Make sure \u0026ldquo;Create a new role with basic Lambda permissions\u0026rdquo; is selected. Paste in the code from slack-bot-rotation.py and click deploy. In the same Code tab of the Lambda function, scroll down to the bottom to add the layer you created in the second phase. Select Custom layers and select the slack_sdk layer from the dropdown, along with the version. Click \u0026ldquo;Add\u0026rdquo; to add it to the Lambda function. After you\u0026rsquo;ve confirmed the layer has been added, go back to the Lambda settings. Click on Configuration -\u0026gt; Permissions and click the role that was created with the Lambda function. You will be brought to the role in the IAM interface. Click \u0026ldquo;Attach policies\u0026rdquo;. A custom policy to allow the Lambda to rotate the secret is required. Click \u0026ldquo;Create policy\u0026rdquo;. Click the JSON tab to enter the custom policy. This is the JSON to copy into the policy with your secret ARN from phase 1: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;AllowLambdaToStoreAndRetrieveSecret\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;secretsmanager:DescribeSecret\u0026#34;, \u0026#34;secretsmanager:GetSecretValue\u0026#34;, \u0026#34;secretsmanager:PutSecretValue\u0026#34;, \u0026#34;secretsmanager:UpdateSecretVersionStage\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;your-secret-arn\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AllowLambdaToListAllSecrets\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;secretsmanager:ListSecrets\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Enter the name and click \u0026ldquo;Create policy\u0026rdquo;. Go back to your IAM role tab with the Lambda role and refresh. You should now be able to attach the created policy by searching for \u0026ldquo;slack\u0026rdquo; in the attach policy page. Now go back to your Lambda function tab and refresh to confirm the function now has access to the secret create in phase 1. You will now need to allow Secrets Manager service to invoke this function on its own. Under Configuration -\u0026gt; Permissions, go to the \u0026ldquo;Resource-based policy\u0026rdquo; section and click \u0026ldquo;Add permissions\u0026rdquo;. In the policy statement select \u0026ldquo;AWS Service\u0026rdquo; and then Secrets Manager from the dropdown. Then choose \u0026ldquo;lambda:InvokeFunction\u0026rdquo; as the Action and give it a Statement ID. Your rotation Lambda function is now ready to be added Secrets Manager for automatic rotation.\nCloudWatch event rule # Fourth, the CloudWatch event rule needs to be created for rotating the Slack bot secret more often than every day.\nFirst the Lambda function used by the CloudWatch rule needs to be created. Go to the Lambda service in your console and click \u0026ldquo;Create function\u0026rdquo; again. Name the function and click \u0026ldquo;Create function\u0026rdquo;. Paste in the slack-bot-rotation-trigger.py code from below and click \u0026ldquo;Deploy\u0026rdquo;. Again we need to edit the created Lambda function role to include the ability to interact with our secret. Click the role under Configuration -\u0026gt; Permissions. Attach and create a policy with the following JSON with ** your secret ARN**: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;AllowLambdaToRotateSecret\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;secretsmanager:RotateSecret\u0026#34;], \u0026#34;Resource\u0026#34;: \u0026#34;your-secret-arn\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AllowLambdaToListAllSecrets\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;secretsmanager:ListSecrets\u0026#34;], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Make sure the created policy is attached. Now go to the CloudWatch service in your console and select \u0026ldquo;Rules\u0026rdquo; under the \u0026ldquo;Events\u0026rdquo; option on the left side. Click \u0026ldquo;Create rule\u0026rdquo;. Create a rule with the following configuration (running every 4 hours and running the Lambda function created above): Name and create the rule. With the rule enabled, the Slack bot token will be rotated every 4 hours and stored in Secrets Manager. Slack Bot Rotation Lambda Function # slack-bot-rotation.py # CloudWatch Event Rule Lambda Function # slack-bot-rotation-trigger.py # While this post is an explainer of what I\u0026rsquo;ve learned on the topic, it could be a great demonstration of Cunningham\u0026rsquo;s Law\u0026hellip;\nThe best way to get the right answer on the internet is not to ask a question; it\u0026rsquo;s to post the wrong answer.\nDo let me know in the comments if you\u0026rsquo;ve found a better way of managing Slack bot token rotation with server-less infrastructure in AWS.\nTerraform # If you use Terraform for managing your AWS infrastructure, I have the configuration for mine below. This is everything I went through in the AWS console above, including the required IAM roles/permissions.\nUsing the above Terraform code, you would use add this object to your tfvars file including your Slack secrets.\nslack_secrets = { client_id = \u0026#34;XXXXXXXXXX\u0026#34; client_secret = \u0026#34;XXXXXXXXXX\u0026#34; slack_bot_token = \u0026#34;xoxb-XXXXXXX\u0026#34; refresh_token = \u0026#34;\u0026#34; slack_signing_secret = \u0026#34;XXXXXXXXXX\u0026#34; } ","date":"30 August 2021","permalink":"/blog/server-less-slack-bot-token-rotation/","section":"Blogs","summary":"Have you ever wanted to manually setup Slack bot token rotation with server-less infrastructure in AWS?","title":"Server-less Slack Bot Token Rotation"},{"content":"","date":"30 August 2021","permalink":"/tags/slack/","section":"Tags","summary":"","title":"slack"},{"content":"","date":"30 August 2021","permalink":"/tags/terraform/","section":"Tags","summary":"","title":"terraform"},{"content":" When responding to an incident involving compromised O365 credentials, the hardest part can often be gathering all the logs required to determine the root cause. Photo by Des Récits on Unsplash Responding to O365 Incidents # While you may quickly discover the damage an attacker has caused to your environment through a compromised Office 365 account, finding out how they initially got in and the entirety of their activity can lead to some frustration. I have found this to be especially true using the default Microsoft tools available for pulling down logs from O365.\nIf your current logging configuration for O365 is not sending the information you need to some kind of centralised log management system, the Hawk PowerShell module created by Canthv0 is extremely helpful for extracting logs from Office 365. It\u0026rsquo;s a whole world better compared to messing around with Search-UnifiedAuditLog and it makes life a lot easier if you\u0026rsquo;re dealing with a large subscription since it pulls logs for individual users into their own folder and organises them by type, depending on the cmdlet you use.\nWhile Hawk is not an official Microsoft tool, it is developed and maintained by a few Microsoft support engineers. Since it is written completely in PowerShell, it makes it easy for O365 admins to pick up and understand. I would recommend anyone that regularly needs to retrieve O365 events add this to their arsenal of tools for O365 log extraction.\nHandling Multi-Domain Tenants # If you ever need to perform exclusions for specific domains within an O365 tenant, see the snippet below that can be used to specify a domain for extraction:\n$AllUsers = (Get-MsolUser -domainname \u0026#34;yourcompanydomain.com\u0026#34;).UserPrincipalName If you are extracting a large amount of user logs and you get interrupted half-way through, it can slow you down when trying to get the full list of user\u0026rsquo;s logs. You can exclude your extraction based on the user folders generated already to avoid pulling logs twice.\n$ExcludedUsers = (Get-ChildItem).Name $MissingUserlogs = ForEach ($u in $AllUsers) { Get-MsolUser -UserPrincipalName $u | Where { $_.UserPrincipalName -NotIn $ExcludedUsers }} You can then check the output of $MissingUserLogs to ensure you are going to pull the correct list users of users on the next Hawk run. Run the next line to gather authentication logs for the remaining users:\nGet-HawkUserAuthHistory -UserPrincipalName $MissingUserlogs.UserPrincipalName Non-American Date Issue # As of 14 September 2020, Hawk does not support using non-US date formats when specifying date ranges, but a pull request has been submitted to the main repo to resolve this issue.\nThis is specifically in reference to using shortcuts noted in the documentation like today or a number of days (e.g. 90). If you use a long-form date like 31-Oct-2019, you can get around problems that come from handling none US date formats.\n","date":"14 September 2020","permalink":"/blog/gathering-o365-logs/","section":"Blogs","summary":"When responding to an incident involving compromised O365 credentials, the hardest part can often be gathering all the logs required to determine the root cause.","title":"Hawk - Tooling for Office 365 Log Gathering"},{"content":"","date":"14 September 2020","permalink":"/tags/incident-response/","section":"Tags","summary":"","title":"incident response"},{"content":"","date":"14 September 2020","permalink":"/tags/o365/","section":"Tags","summary":"","title":"O365"},{"content":" I\u0026rsquo;m an information security professional based in New Zealand.\nThe purpose of this blog is to share my experience with the wider Infosec community with the hope that other defenders may find some useful nuggets of information to make life easier. The content will mostly be small bits of advice or stories of what I come across in my work life.\nI will also publish write-ups for things I work on in my limited spare time. The ideas and opinions published on this blog are my own.\n","date":"13 July 2020","permalink":"/about-me/","section":"h0wl","summary":"I\u0026rsquo;m an information security professional based in New Zealand.","title":"About Me"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]